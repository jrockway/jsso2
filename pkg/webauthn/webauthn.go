package webauthn

import (
	"bytes"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/duo-labs/webauthn/protocol"
	"github.com/duo-labs/webauthn/protocol/webauthncose"
	"github.com/duo-labs/webauthn/webauthn"
	"github.com/jrockway/jsso2/pkg/jssopb"
	"github.com/jrockway/jsso2/pkg/sessions"
	"github.com/jrockway/jsso2/pkg/types"
	"github.com/jrockway/jsso2/pkg/webauthnpb"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/durationpb"
)

type Config struct {
	RelyingPartyID   string
	RelyingPartyName string
	Origin           string
}

var (
	ErrNoCredentials          = errors.New("no credentials; try enrolling an authenticator")
	ErrNotPublicKey           = errors.New("the authentication material is not of type 'public-key'")
	ErrNotAttestationResponse = errors.New("AuthenticatorResponse is not an AuthenticatorAttestationResponse")
	ErrNotAssertionResponse   = errors.New("AuthenticatorResponse is not an AuthenticatorAssertionResponse")

	encoder = base64.URLEncoding.WithPadding(base64.NoPadding)
)

func unpackProtocolError(err error) error {
	protocolErr := new(protocol.Error)
	if errors.As(err, &protocolErr) {
		info := protocolErr.DevInfo
		// These contain garbage that messes up your terminal.
		if strings.HasPrefix(info, "RP Hash mismatch") {
			info = "RP Hash mismatch"
		}
		info = strings.ReplaceAll(info, "\n", " ")
		return fmt.Errorf("validate attestation object: %w (type: %s, dev info: %s)", err, protocolErr.Type, info)
	}
	return err
}

var optsPrototype = &webauthnpb.PublicKeyCredentialCreationOptions{
	Attestation: webauthnpb.PublicKeyCredentialCreationOptions_NONE,
	Timeout:     durationpb.New(60 * time.Second),
	PubKeyCredParams: func() []*webauthnpb.PublicKeyCredentialParameters {
		var result []*webauthnpb.PublicKeyCredentialParameters
		algs := []webauthncose.COSEAlgorithmIdentifier{
			webauthncose.AlgES256,
			webauthncose.AlgES384,
			webauthncose.AlgES512,
			webauthncose.AlgRS256,
			webauthncose.AlgRS384,
			webauthncose.AlgRS512,
			webauthncose.AlgPS256,
			webauthncose.AlgPS384,
			webauthncose.AlgPS512,
			webauthncose.AlgEdDSA,
		}
		for _, alg := range algs {
			result = append(result, &webauthnpb.PublicKeyCredentialParameters{
				Alg:  int32(alg),
				Type: "public-key",
			})
		}
		return result
	}(),
}

func userAsBinary(id int64) ([]byte, error) {
	buf := new(bytes.Buffer)
	if err := binary.Write(buf, binary.BigEndian, id); err != nil {
		return nil, fmt.Errorf("write user id to byte buffer: %w", err)
	}
	return buf.Bytes(), nil
}

// BeginEnrollment starts the enrollment process, returning a PublicKeyCredentialCreationOptions
// for the browser.
func (c *Config) BeginEnrollment(session *types.Session, existingCreds []*types.Credential) (*webauthnpb.PublicKeyCredentialCreationOptions, error) {
	opts := proto.Clone(optsPrototype).(*webauthnpb.PublicKeyCredentialCreationOptions)
	opts.Challenge = session.GetId()
	opts.Rp = &webauthnpb.PublicKeyCredentialRpEntity{
		Id:   c.RelyingPartyID,
		Name: c.RelyingPartyName,
	}
	user := session.GetUser()
	if user.GetId() < 1 {
		return nil, errors.New("invalid user attempting enrollment")
	}
	idBytes, err := userAsBinary(user.GetId())
	if err != nil {
		return nil, fmt.Errorf("format user id as binary: %w", err)
	}
	opts.User = &webauthnpb.PublicKeyCredentialUserEntity{
		Id:          idBytes,
		DisplayName: user.GetUsername(),
		Name:        user.GetUsername(),
	}
	for _, c := range existingCreds {
		opts.ExcludeCredentials = append(opts.ExcludeCredentials, &webauthnpb.PublicKeyCredentialDescriptor{
			Id:   c.GetCredentialId(),
			Type: "public-key",
			Transports: []webauthnpb.PublicKeyCredentialDescriptor_AuthenticatorTransport{
				webauthnpb.PublicKeyCredentialDescriptor_BLE,
				webauthnpb.PublicKeyCredentialDescriptor_INTERNAL,
				webauthnpb.PublicKeyCredentialDescriptor_NFC,
				webauthnpb.PublicKeyCredentialDescriptor_USB,
			},
		})
	}
	return opts, nil
}

type ClientData struct {
	Challenge   string `json:"challenge"`
	CrossOrigin bool   `json:"crossOrigin"`
	Origin      string `json:"origin"`
	Type        string `json:"type"`
}

// Verify the authenticator response generated by the client.  Because we use a slightly different
// RPC format than Duo's webauthn library, we do the non-crypto things here, and delegate to that
// library to verify signations.  The steps below are from:
// https://www.w3.org/TR/webauthn/#registering-a-new-credential
func (c *Config) FinishEnrollment(session *types.Session, req *jssopb.FinishEnrollmentRequest) (*types.Credential, error) {
	switch req.GetCredential().GetResponse().GetResponse().(type) {
	case *webauthnpb.AuthenticatorResponse_AttestationResponse:
	default:
		return nil, ErrNotAttestationResponse
	}
	// Step 1: Let JSONtext be the result of running UTF-8 decode on clientDataJSON.  (We
	// actually do this on the client side since gRPC lets use send raw bytes on the wire unlike
	// the JSON that the spec assumes you're going to use; see src/lib/webauthn.ts.)
	//
	// Step 2: Let C be the result of running a JSON parser on the clientDataJSON.  (We call it
	// clientData.)
	clientDataJSON := req.GetCredential().GetResponse().GetClientDataJson()
	var clientData ClientData
	if err := json.Unmarshal(clientDataJSON, &clientData); err != nil {
		return nil, fmt.Errorf("unmarshal client data json: %w", err)
	}

	// Step 3: Verify that C.type is webauthn.create.
	if got, want := clientData.Type, "webauthn.create"; got != want {
		return nil, fmt.Errorf("client data type: got %q, want %q", got, want)
	}

	// Step 4: Verify that the value of C.challenge matches the challenge that was sent to the
	// authenticator.
	//
	// The challenge comes back as a base64url string, which purely by coincidence matches what
	// sessions.ToBase64 does.  We send the challenge as raw bytes, we transport it in the
	// frontend as raw bytes, but when the browser adds it to the clientDataJSON, it uses
	// url-safe base64.
	//
	// https://www.w3.org/TR/webauthn/#dom-collectedclientdata-challenge
	if got, want := clientData.Challenge, sessions.ToBase64(session); got != want {
		return nil, fmt.Errorf("provided challenge does not match the current session: got %q, want %q", got, want)
	}

	// Step 5: Verify that the value of C.origin matches the Relying Party's origin.
	if got, want := clientData.Origin, c.Origin; got != want {
		return nil, fmt.Errorf("credential from invalid origin: got %q, want %q", got, want)
	}
	if clientData.CrossOrigin {
		return nil, errors.New("rejecting cross-origin credential")
	}

	// Step 6: Verify that the value of C.TokenBinding.status matches the state of Token Binding
	// for the TLS connection.
	// TODO(jrockway): Do this?

	// Step 7: Compute the hash of clientDataJSON using SHA-256.
	clientDataHash := sha256.New().Sum(clientDataJSON)

	// Step 8: Perform CBOR decoding on attestationObject.
	attestationResponse := protocol.AuthenticatorAttestationResponse{
		AuthenticatorResponse: protocol.AuthenticatorResponse{
			ClientDataJSON: req.Credential.GetResponse().GetClientDataJson(),
		},
		AttestationObject: req.Credential.GetResponse().GetAttestationResponse().GetAttestationObject(),
	}
	attestation, err := attestationResponse.Parse()
	if err != nil {
		return nil, fmt.Errorf("parsing attestation response: %w", err)
	}
	// Step 9: Verify the rpIdHash.  (Handled by Verify.)
	// Step 10: Verify that UserPresent is set.  (Handled by Verify.)
	// Step 11: We skip user verification.
	// Step 12: Verify the client extensions.  Skipped.
	// Step 13: Verify the attestation format.  (Handled by Verify.)
	// Step 14: Verify that the attestation statement is correct.
	if err := attestation.AttestationObject.Verify(c.RelyingPartyID, clientDataHash, false); err != nil {
		return nil, fmt.Errorf("validate attestation object: %w", unpackProtocolError(err))
	}

	// Step 15: Obtain trust anchors.  The Duo library claims this is impossible to do, so we
	// don't.
	//
	// Step 16: Assess the attestation trustworthines.  The Duo library also skips this.
	//
	// Step 17: Check that no other user has this credential ID.  Handled by the caller.
	//
	// Step 18: Associate the credential with the user.  Handled by the caller.
	//
	// Step 19: If the attestation statement is not trustworthy, fail.  (Skipped.)
	attData := attestation.AttestationObject.AuthData.AttData
	return &types.Credential{
		CredentialId: attData.CredentialID,
		PublicKey:    attData.CredentialPublicKey,
	}, nil
}

// BeginLogin fills out a StartLoginReply so that login can begin.
func (c *Config) BeginLogin(s *types.Session, creds []*types.Credential) (*jssopb.StartLoginReply, error) {
	reply := &jssopb.StartLoginReply{
		CredentialRequestOptions: &webauthnpb.PublicKeyCredentialRequestOptions{
			Timeout: durationpb.New(60 * time.Second),
		},
	}
	reply.CredentialRequestOptions.Challenge = s.GetId()

	if len(creds) == 0 {
		return reply, ErrNoCredentials
	}
	for _, c := range creds {
		reply.CredentialRequestOptions.AllowedCredentials = append(reply.CredentialRequestOptions.AllowedCredentials, &webauthnpb.PublicKeyCredentialDescriptor{
			Id: c.CredentialId,
			Transports: []webauthnpb.PublicKeyCredentialDescriptor_AuthenticatorTransport{
				webauthnpb.PublicKeyCredentialDescriptor_BLE,
				webauthnpb.PublicKeyCredentialDescriptor_INTERNAL,
				webauthnpb.PublicKeyCredentialDescriptor_NFC,
				webauthnpb.PublicKeyCredentialDescriptor_USB,
			},
			Type: "public-key",
		})
	}
	return reply, nil
}

type webauthnUser struct {
	id    []byte
	user  *types.User
	creds []*types.Credential
}

func (u *webauthnUser) WebAuthnID() []byte {
	return u.id
}

func (u *webauthnUser) WebAuthnName() string {
	return u.user.GetUsername()
}

func (u *webauthnUser) WebAuthnDisplayName() string {
	return u.user.GetUsername()
}

func (*webauthnUser) WebAuthnIcon() string { return "" }

func (u *webauthnUser) WebAuthnCredentials() []webauthn.Credential {
	var result []webauthn.Credential
	for _, c := range u.creds {
		result = append(result, webauthn.Credential{
			ID:            c.GetCredentialId(),
			PublicKey:     c.GetPublicKey(),
			Authenticator: webauthn.Authenticator{},
		})
	}
	return result
}

// FinishLogin validates a signature against of allowed credentials.
func (c *Config) FinishLogin(s *types.Session, creds []*types.Credential, req *jssopb.FinishLoginRequest) error {
	if req.GetCredential().GetType() != "public-key" {
		return ErrNotPublicKey
	}
	switch req.GetCredential().GetResponse().GetResponse().(type) {
	case *webauthnpb.AuthenticatorResponse_AssertionResponse:
	default:
		return ErrNotAssertionResponse
	}

	res := req.GetCredential().GetResponse()
	ares := res.GetAssertionResponse()

	var clientData protocol.CollectedClientData
	if err := json.Unmarshal(res.GetClientDataJson(), &clientData); err != nil {
		return fmt.Errorf("unmarshal client data json: %w", err)
	}
	ad := protocol.AuthenticatorData{}
	if err := ad.Unmarshal(ares.GetAuthenticatorData()); err != nil {
		return fmt.Errorf("unmarshal attestation object: %w", err)
	}
	rawID, err := encoder.DecodeString(req.GetCredential().GetId())
	if err != nil {
		return fmt.Errorf("decode credential id: %w", err)
	}
	cad := &protocol.ParsedCredentialAssertionData{
		ParsedPublicKeyCredential: protocol.ParsedPublicKeyCredential{
			RawID: rawID,
			ParsedCredential: protocol.ParsedCredential{
				ID:   req.GetCredential().GetId(),
				Type: req.GetCredential().GetType(),
			},
		},
		Response: protocol.ParsedAssertionResponse{
			CollectedClientData: clientData,
			AuthenticatorData:   ad,
			Signature:           ares.GetSignature(),
			UserHandle:          ares.GetUserHandle(),
		},
		Raw: protocol.CredentialAssertionResponse{
			AssertionResponse: protocol.AuthenticatorAssertionResponse{
				AuthenticatorResponse: protocol.AuthenticatorResponse{
					ClientDataJSON: res.GetClientDataJson(),
				},
				AuthenticatorData: ares.GetAuthenticatorData(),
				Signature:         ares.GetSignature(),
				UserHandle:        ares.GetUserHandle(),
			},
		},
	}
	var credIDs [][]byte
	for _, c := range creds {
		credIDs = append(credIDs, c.GetCredentialId())
	}
	idBytes, err := userAsBinary(s.GetUser().GetId())
	if err != nil {
		return fmt.Errorf("format user id as binary: %w", err)
	}
	u := &webauthnUser{
		id:    idBytes,
		user:  s.GetUser(),
		creds: creds,
	}
	session := webauthn.SessionData{
		Challenge:            sessions.ToBase64(s),
		UserID:               idBytes,
		AllowedCredentialIDs: credIDs,
		UserVerification:     protocol.VerificationDiscouraged,
	}
	cfg := &webauthn.WebAuthn{
		Config: &webauthn.Config{
			RPDisplayName: c.RelyingPartyName,
			RPID:          c.RelyingPartyID,
			RPOrigin:      c.Origin,
		},
	}
	if _, err := cfg.ValidateLogin(u, session, cad); err != nil {
		return fmt.Errorf("validate login: %w", unpackProtocolError(err))
	}
	return nil
}
